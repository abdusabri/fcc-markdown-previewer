{"version":3,"sources":["components/editor.js","components/preview.js","utils/markdown-parser.js","components/previewer-container.js","utils/default-text.js","app.js","serviceWorker.js","index.js"],"names":["Editor","_ref","text","onChange","react_default","a","createElement","className","CardHeader_default","title","Paper_default","style","height","id","value","Preview","lib","autoHide","Parser","hljs","registerLanguage","javascript","parseTextToMarkdown","marked","sanitize","sanitizer","sanitizeHtml","highlight","code","highlightAuto","breaks","PreviewerContainer","state","markedText","event","_this","setState","target","defaultText","this","editor","preview","Component","App","components_previewer_container","Boolean","window","location","hostname","match","ReactDOM","render","src_app","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"gWA2BeA,EArBA,SAAAC,GAAwB,IAArBC,EAAqBD,EAArBC,KAAMC,EAAeF,EAAfE,SACtB,OACEC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,SACbH,EAAAC,EAAAC,cAACE,EAAAH,EAAD,CAAYI,MAAM,WAClBL,EAAAC,EAAAC,cAACI,EAAAL,EAAD,CAAOM,MAAO,CAAEC,OAAQ,SACtBR,EAAAC,EAAAC,cAAA,YACEO,GAAG,SACHN,UAAU,qBACVO,MAAOZ,EACPC,SAAUA,gCCaLY,EApBC,SAAAd,GAAc,IAAXC,EAAWD,EAAXC,KACjB,OACEE,EAAAC,EAAAC,cAAA,OAAKC,UAAU,SACbH,EAAAC,EAAAC,cAACE,EAAAH,EAAD,CAAYI,MAAM,YAElBL,EAAAC,EAAAC,cAACI,EAAAL,EAAD,CAAOM,MAAO,CAAEC,OAAQ,SACtBR,EAAAC,EAAAC,cAACU,EAAA,WAAD,CAAYC,UAAQ,GAClBb,EAAAC,EAAAC,cAAA,OAAKO,GAAG,UAAUN,UAAU,sBACzBW,IAAOhB,mFCXpBiB,IAAKC,iBAAiB,aAAcC,KAE7B,IAAMC,EAAsB,SAAApB,GACjC,OAAOqB,IAAOrB,EAAM,CAClBsB,UAAU,EACVC,UAAWC,IACXC,UAAW,SAASC,GAClB,OAAOT,IAAKU,cAAcD,GAAMd,OAElCgB,QAAQ,KCoBGC,6MA1BbC,MAAQ,CACN9B,KAAM,GACN+B,WAAY,MASd9B,SAAW,SAAA+B,GACTC,EAAKC,SAAS,CAAElC,KAAMgC,EAAMG,OAAOvB,QACnCqB,EAAKC,SAAS,CAAEH,WAAYX,EAAoBY,EAAMG,OAAOvB,6FAP7D,IAAMwB,ECdoB,6qDDe1BC,KAAKH,SAAS,CAAElC,KAAMoC,IACtBC,KAAKH,SAAS,CAAEH,WAAYX,EAAoBgB,sCAShD,OACElC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,uBACbH,EAAAC,EAAAC,cAACkC,EAAD,CAAQtC,KAAMqC,KAAKP,MAAM9B,KAAMC,SAAUoC,KAAKpC,WAC9CC,EAAAC,EAAAC,cAACmC,EAAD,CAASvC,KAAMqC,KAAKP,MAAMC,qBArBDS,aEGlBC,2LAJX,OAAOvC,EAAAC,EAAAC,cAACsC,EAAD,aAFOF,cCQEG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO/C,EAAAC,EAAAC,cAAC8C,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.b1e93418.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./panels.css\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport CardHeader from \"@material-ui/core/CardHeader\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nconst Editor = ({ text, onChange }) => {\r\n  return (\r\n    <div className=\"panel\">\r\n      <CardHeader title=\"Editor\" />\r\n      <Paper style={{ height: \"100%\" }}>\r\n        <textarea\r\n          id=\"editor\"\r\n          className=\"markdown-container\"\r\n          value={text}\r\n          onChange={onChange}\r\n        />\r\n      </Paper>\r\n    </div>\r\n  );\r\n};\r\n\r\nEditor.propTypes = {\r\n  text: PropTypes.string.isRequired,\r\n  onChange: PropTypes.func.isRequired\r\n};\r\n\r\nexport default Editor;\r\n","import React from \"react\";\r\nimport \"./panels.css\";\r\nimport Paper from \"@material-ui/core/Paper\";\r\nimport CardHeader from \"@material-ui/core/CardHeader\";\r\nimport PropTypes from \"prop-types\";\r\nimport Parser from \"html-react-parser\";\r\nimport { Scrollbars } from \"react-custom-scrollbars\";\r\n\r\nconst Preview = ({ text }) => {\r\n  return (\r\n    <div className=\"panel\">\r\n      <CardHeader title=\"Preview\" />\r\n\r\n      <Paper style={{ height: \"100%\" }}>\r\n        <Scrollbars autoHide>\r\n          <div id=\"preview\" className=\"markdown-container\">\r\n            {Parser(text)}\r\n          </div>\r\n        </Scrollbars>\r\n      </Paper>\r\n    </div>\r\n  );\r\n};\r\n\r\nPreview.propTypes = {\r\n  text: PropTypes.string.isRequired\r\n};\r\n\r\nexport default Preview;\r\n","import marked from \"marked\";\r\nimport sanitizeHtml from \"sanitize-html\";\r\nimport hljs from \"highlight.js/lib/highlight\";\r\nimport javascript from \"highlight.js/lib/languages/javascript\";\r\nimport \"highlight.js/styles/github.css\";\r\nhljs.registerLanguage(\"javascript\", javascript);\r\n\r\nexport const parseTextToMarkdown = text => {\r\n  return marked(text, {\r\n    sanitize: true,\r\n    sanitizer: sanitizeHtml,\r\n    highlight: function(code) {\r\n      return hljs.highlightAuto(code).value;\r\n    },\r\n    breaks: true\r\n  });\r\n};\r\n","import React, { Component } from \"react\";\r\nimport \"./previewer-container.css\";\r\nimport Editor from \"./editor\";\r\nimport Preview from \"./preview\";\r\nimport { parseTextToMarkdown } from \"../utils/markdown-parser\";\r\nimport { getDefaultText } from \"../utils/default-text\";\r\n\r\nclass PreviewerContainer extends Component {\r\n  state = {\r\n    text: \"\",\r\n    markedText: \"\"\r\n  };\r\n\r\n  componentDidMount() {\r\n    const defaultText = getDefaultText();\r\n    this.setState({ text: defaultText });\r\n    this.setState({ markedText: parseTextToMarkdown(defaultText) });\r\n  }\r\n\r\n  onChange = event => {\r\n    this.setState({ text: event.target.value });\r\n    this.setState({ markedText: parseTextToMarkdown(event.target.value) });\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"previewer-container\">\r\n        <Editor text={this.state.text} onChange={this.onChange} />\r\n        <Preview text={this.state.markedText} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PreviewerContainer;\r\n","export const getDefaultText = () =>\r\n  `Marked - Markdown Parser\r\n========================\r\n\r\n[Marked] lets you convert [Markdown] into HTML.  Markdown is a simple text format whose goal is to be very easy to read and write, even when not converted to HTML.  This demo page will let you type anything you like and see how it gets converted.  Live.  No more waiting around.\r\n\r\nHow To Use The Demo\r\n-------------------\r\n\r\n1. Type in stuff on the left.\r\n2. See the live updates on the right.\r\n\r\nThat's it.  Pretty simple.  There's also a drop-down option in the upper right to switch between various views:\r\n\r\n- **Preview:**  A live display of the generated HTML as it would render in a browser.\r\n- **HTML Source:**  The generated HTML before your browser makes it pretty.\r\n- **Lexer Data:**  What [marked] uses internally, in case you like gory stuff like this.\r\n- **Quick Reference:**  A brief run-down of how to format things using markdown.\r\n\r\nWhy Markdown?\r\n-------------\r\n\r\nIt's easy.  It's not overly bloated, unlike HTML.  Also, as the creator of [markdown] says,\r\n\r\n> The overriding design goal for Markdown's\r\n> formatting syntax is to make it as readable\r\n> as possible. The idea is that a\r\n> Markdown-formatted document should be\r\n> publishable as-is, as plain text, without\r\n> looking like it's been marked up with tags\r\n> or formatting instructions.\r\n\r\n[Marked]: https://github.com/markedjs/marked/\r\n[Markdown]: http://daringfireball.net/projects/markdown/\r\n\r\n## Some more examples\r\n**Here is an image**\r\n\r\n![Lorem Ipsum](https://picsum.photos/400 \"Lorem Ipsum\")\r\n\r\n**Here is a code block**\r\n\r\n\\`\\`\\`\r\n    var s = \r\n        \"JavaScript syntax highlighting\";\\`\\`\\`\r\n\r\nHere is an inline code \\`var s = \"JavaScript syntax highlighting\";\\`\r\n`;\r\n","import React, { Component } from \"react\";\r\nimport PreviewerContainer from \"./components/previewer-container\";\r\nimport \"./app.css\";\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return <PreviewerContainer />;\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}